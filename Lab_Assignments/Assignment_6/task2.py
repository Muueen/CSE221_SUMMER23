# -*- coding: utf-8 -*-
"""task2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LZNmCPqm8b6Fsqkpu85JTbe-Kk833F3A
"""

infile = open("/content/drive/MyDrive/cse221_ass06/input2_3.txt", "r")
outfile = open("/content/drive/MyDrive/cse221_ass06/output2_3.txt", "w")

l = infile.readlines()
nm = list(map(int, l[0].split(" ")))
n = nm[0]
m = nm[1]
sd = list(map(int, l[len(l)-1].split(" ")))
s = sd[0]
d = sd[1]
for elem in l:
    elem = elem.strip("\n")
def adjL(l):
    dic = {}
    for e2 in range(1, len(l)-1):
        l[e2] = list(map(int, l[e2].split(" ")))
        i = l[e2][0]
        j = l[e2][1]
        w = l[e2][2]
        if i in dic:
            dic[i].append((j, w))
        else:
            dic[i] = [(j, w)]
        if j not in dic:
            dic[j] = []
    return dic
g = adjL(l)

def inout(g):
    dic = {}
    for lis in g.values():
        for j in lis:
            v = j[0]
            if v not in dic:
                dic[v] = 1
            else:
                dic[v] += 1
    return dic

def dijkstra(g, s, n):
    dist = [1000000000] * (n + 1)
    dist_min = [1000000000] * (n + 1)
    dist[s] = 0
    visited = [False] * (n+1)
    f = True
    u = s
    visited[0] = True
    indeg = inout(g)
    for i in range(1, n+1):
        if i not in indeg and i != s:
            visited[i] = True
    c = 0
    while f == True:
        c += 1
        if visited[u] == False:
            visited[u] = True
            for tup in g[u]:
                v = tup[0]
                cost = tup[1]
                if dist[v] > dist[u] + cost:
                    dist[v] = dist[u] + cost
                    dist_min[v] = dist[u] + cost
        mini = min(dist_min)
        u = dist_min.index(mini)
        dist_min[u] = 1000000000
        if False not in visited or c > m:
            f = False
    for i in range(1, len(dist)):
        if dist[i] == 1000000000:
            dist[i] = -1
    return dist

path_s = dijkstra(g, s, n)
path_d = dijkstra(g, d, n)
aux = []
minim = 999999999
for i in range(1, len(path_s)):
    if path_s[i] == -1 or path_d[i] == -1:
        pass
    else:
        if path_s[i] > path_d[i]:
            el = path_s[i]
            aux.append(el)
        else:
            el = path_d[i]
            aux.append(el)
        if el < minim:
            minim = el
            idx = i
if len(aux) == 0:
    line = "Impossible"
else:
    line = f"Time {minim}\nNode {idx}"
outfile.writelines(line)